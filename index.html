<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BDO Ship Upgrade Recipe Tracker</title>
    <script src="https://cdn.rawgit.com/brython-dev/brython/3.6.2/www/src/brython.js" type="text/javascript"></script>
    <script src="https://cdn.rawgit.com/brython-dev/brython/3.6.2/www/src/brython_stdlib.js" type="text/javascript"></script>
    <link href="css/layout.css" rel="stylesheet" type="text/css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body onload="brython(1)">
    <section class="main">
        This site uses local storage to save your choices. <br /><br /><br />
        <b>Select a ship: </b></strong><span id="shiplist"></span><br /><br />
        <span id="shipparts"></span>
        <br /><span id="reset"></span>(warning not reversible)
    </section>
    <script type="text/python">
        from browser import document as doc
        from browser import html
        from browser.html import TABLE, TR, TH, TD, BR, H3, SPAN
        from browser.local_storage import storage
        from recipes import recipes
        from tradein import barters
        from vendor_items import items
        from ships import ships
        from information import gen_info

        # Given a part name, returns a string with information about that part
        # returns empty string if no information
        def notes(val):
            ret = []
            if val in items:
                for i in items[val]:
                    ret.append(i + BR())
            if val in recipes and val not in ships:
                for i in recipes[val]:
                    ret.append("Recipe: {}x {}".format(recipes[val][i], i) + BR())
            if val in barters:
                for c, item in enumerate(barters[val]["input"]):
                    ret.append("{} per ".format(barters[val]['count']) + SPAN(item, Class="trade{}".format(item[item.find(']') - 1])) + BR())
            return ret


        # update missing parts
        def update_missing():
            missing = {}
            for item in doc.select(".current"):
                count = int(item['data-max']) - int(doc[item['id']].value)
                if count:
                    if "+" not in item['data-name']:
                        missing[item['data-name']] = count
                    else:
                        count = 1
                    if item['data-name'] in ships:
                        continue

                    queue = [(item['data-name'], count)]
                    while queue:
                        current, c_count = queue.pop()
                        if current in recipes:

                            for i in recipes[current]:
                                n_count = c_count * recipes[current][i]
                                if "+" not in i:
                                    if i not in missing:
                                        missing[i] = 0
                                    missing[i] += n_count
                                queue.append((i, n_count))
                            if any(["+{} ".format(int(doc[item['id']].value)) in x or x.startswith("Epheria") for x in recipes[current]]):
                                queue = []

            t = TABLE(TR(TH("Count")+TH("Name")+TH("Notes")))

            for item in sorted(missing):
                t <= TR(TD(missing[item])+TD(item)+TD(notes(item)))

            doc['missing'].text = ''
            doc['missing'] <= t


        # Update the stored value of an item
        def update_count(ev):
            storage[ev.currentTarget['id']] = ev.currentTarget.value
            update(None)


        # Code to show an about page and miscellaneous information.
        def show_info():
            def draw_line(cotx, sx, sy, tx, ty):
                cotx.moveTo(sx, sy);
                cotx.lineTo(tx, ty);
                cotx.stroke();

            doc['shipparts'].text = ''
            doc['shipparts'] <= gen_info()
            font = 18
            canvas = doc["shipchart"]
            voffset = canvas.height/font+10
            hval = [
                0,
                10*len("Bartali Sailboat"),
                10*max(len("Epheria Sailboat"), len("Epheria Frigate")),
                10*max(len("Improved Sailboat"), len("Improved Frigate")),
                10*max(len("Epheria Caravel"), len("Epheria Galleass")),
                10*len("Epheria Carrack")
            ]
            hoffset = []
            for idx in range(1,len(hval)+1):
                hoffset.append(sum(hval[:idx]))
            center = canvas.height/2
            ctx = canvas.getContext("2d")
            ctx.font = "{}px monospace".format(font)

            ctx.fillStyle = "#FFFFFF"
            draw_line(ctx, hoffset[0] + hval[1]/2, center            , hoffset[1] + hval[2]/2, center - 3*voffset)  # Bartali -> Sailboat
            draw_line(ctx, hoffset[1] + hval[2]/2, center - 3*voffset, hoffset[2] + hval[3]/2, center - 1*voffset)  # sailboat -> improved
            draw_line(ctx, hoffset[1] + hval[2]/2, center - 3*voffset, hoffset[3] + hval[4]/2, center - 3*voffset)  # sailboat -> caravel
            draw_line(ctx, hoffset[2] + hval[3]/2, center - 1*voffset, hoffset[3] + hval[4]/2, center - 3*voffset)  # improved -> caravel
            draw_line(ctx, hoffset[3] + hval[4]/2, center - 3*voffset, hoffset[4] + hval[5]/2, center - 5*voffset)  # caravel -> carrack (advance)
            draw_line(ctx, hoffset[3] + hval[4]/2, center - 3*voffset, hoffset[4] + hval[5]/2, center - 1*voffset)  # caravel -> carrack (balance)

            draw_line(ctx, hoffset[0] + hval[1]/2, center            , hoffset[1] + hval[2]/2, center + 3*voffset)  # Bartali -> Frigate
            draw_line(ctx, hoffset[1] + hval[2]/2, center + 3*voffset, hoffset[2] + hval[3]/2, center + 1*voffset)  # frigate -> improved
            draw_line(ctx, hoffset[1] + hval[2]/2, center + 3*voffset, hoffset[3] + hval[4]/2, center + 3*voffset)  # frigate -> galleass
            draw_line(ctx, hoffset[2] + hval[3]/2, center + 1*voffset, hoffset[3] + hval[4]/2, center + 3*voffset)  # improved -> galleass
            draw_line(ctx, hoffset[3] + hval[4]/2, center + 3*voffset, hoffset[4] + hval[5]/2, center + 1*voffset)  # galleass -> carrack (valor)
            draw_line(ctx, hoffset[3] + hval[4]/2, center + 3*voffset, hoffset[4] + hval[5]/2, center + 5*voffset)  # galleass -> carrack (volante)

            ctx.fillRect(0, center-font, 10*len("Bartali Sailboat"), font*1.5)
            
            ctx.fillRect(hoffset[1], center-font - 3*voffset, 10*len("Epheria Sailboat"), font*1.5)
            ctx.fillRect(hoffset[2], center-font - 1*voffset, 10*len("Improved Sailboat"), font*1.5)
            ctx.fillRect(hoffset[3], center-font - 3*voffset, 10*len("Epheria Caravel"), font*1.5)
            ctx.fillRect(hoffset[4], center-font - 5*voffset, 10*len("Epheria Carrack"), font*2.5)
            ctx.fillRect(hoffset[4], center-font - 1*voffset, 10*len("Epheria Carrack"), font*2.5)

            ctx.fillRect(hoffset[1], center-font + 3*voffset, 10*len("Epheria Frigate"), font*1.5)
            ctx.fillRect(hoffset[2], center-font + 1*voffset, 10*len("Improved Frigate"), font*1.5)
            ctx.fillRect(hoffset[3], center-font + 3*voffset, 10*len("Epheria Galleass"), font*1.5)
            ctx.fillRect(hoffset[4], center-font + 1*voffset, 10*len("Epheria Carrack"), font*2.5)
            ctx.fillRect(hoffset[4], center-font + 5*voffset, 10*len("Epheria Carrack"), font*2.5)

            ctx.fillStyle = "#000000"
            ctx.textAlign = "left"
            ctx.fillText("Bartali Sailboat", 0, center)

            ctx.fillText("Epheria Sailboat", hoffset[1], center - 3*voffset)
            ctx.fillText("Epheria Frigate", hoffset[1], center + 3*voffset)

            ctx.fillText("Improved Sailboat", hoffset[2], center - 1*voffset)
            ctx.fillText("Improved Frigate", hoffset[2], center + 1*voffset)

            ctx.fillText("Epheria Caravel", hoffset[3], center - 3*voffset)
            ctx.fillText("Epheria Galleass", hoffset[3], center + 3*voffset)

            ctx.fillText("Epheria Carrack", hoffset[4], center - 5*voffset)
            ctx.fillText("(Advance)", hoffset[4], center - 5*voffset+font+2)
            ctx.fillText("Epheria Carrack", hoffset[4], center - 1*voffset)
            ctx.fillText("(Balance)", hoffset[4], center - 1*voffset+font+2)
            ctx.fillText("Epheria Carrack", hoffset[4], center + 5*voffset)
            ctx.fillText("(Volante)", hoffset[4], center + 5*voffset+font+2)
            ctx.fillText("Epheria Carrack", hoffset[4], center + 1*voffset)
            ctx.fillText("(Valor)", hoffset[4], center + 1*voffset+font+2)

            return


        # Change what is displayed to match current selection
        def update(ev):
            if ev:
                storage['ship'] = ev.currentTarget.value
            eventname = storage['ship']
            if eventname == "Information":
                show_info()
                return
            # add green gear items for carracks
            recipesextra = {}
            for part in recipes[eventname].keys():
                id = "{}-{}".format(eventname, part)
                if '+' in part and part[4:] in recipes and (id not in storage or storage[id] == '0'):
                    for i in recipes[part[4:]]:
                        if "+" in i:
                            recipesextra[i] = 1
                            break

            t = TABLE()
            t <= TR(TH("Count") + TH("Max") + TH("Name"))
            ids = []
            for part in {**recipes[eventname], **recipesextra}:
                newid = "{}-{}".format(eventname, part)
                ids.append(newid)
                sel = html.SELECT(size=1, multiple=False, id=newid)
                val = 10 if '+' in part else recipes[eventname][part]
                sel['data-max'] = val
                sel['data-name'] = part
                sel['class'] = "current"
                sel.bind("change", update_count)
                for i in range(val+1):
                    sel <= html.OPTION(i)
                t <= TR(TD(sel) + TD(val) + TD("{} (select level)".format(part[4:]) if '+' in part else part))

            doc['shipparts'].text = ''
            doc['shipparts'] <= t
            doc['shipparts'] <= BR() + BR() + H3("Missing parts") + SPAN(id="missing")

            # iterate over selection boxes and set to values in local storage.
            for id in ids:
                if id in storage:
                    doc[id].value = storage[id]
            update_missing()


        # Initialize our list of ships and select the previous one if a choice exists
        def create_ship_list():
            sel = html.SELECT(size=1, multiple=False, id="ship")
            for ship in ships:
                sel <= html.OPTION(ship)
            sel.bind("change", update)
            doc['shiplist'] <= sel
            if 'ship' in storage and storage['ship'] in ships:
                doc['ship'].value = storage['ship']
            update(None)


        def reset_data(ev):
            for key in storage.keys():
                del storage[key]
            storage['ship'] = ships[0]
            doc['ship'].value = storage['ship']
            update(None)

        b_reset = html.BUTTON("Reset Data")
        b_reset.bind("click", reset_data)
        doc["reset"] <= b_reset
        create_ship_list()


    </script>

</body>
</html>